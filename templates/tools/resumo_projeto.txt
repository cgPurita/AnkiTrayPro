=== RAIO-X DO PROJETO: AnkiTrayPro ===
Gerado em: 2026-01-10 02:41:36.896742
Copyright ¬© 2025 Caio Graco Purita
==================================================

--- ESTRUTURA DE ARQUIVOS ---
[AnkiTrayPro/]
    .gitattributes
    .gitignore
    config.json
    consts.py
    gui.py
    LICENSE
    manifest.json
    meta.json
    notifications.py
    README.md
    tray.py
    __init__.py
    [lang/]
        en.py
        pt.py
        __init__.py
    [templates/]
        [ide/]
            [vscode/]
                settings.json
        [legal/]
            CABE√áALHO_PROPRIETARIO.txt
        [tools/]

==================================================

--- CONTE√öDO DOS ARQUIVOS ---

FILE: .gitattributes
--------------------
# Auto detect text files and perform LF normalization
* text=auto

==================================================

FILE: .gitignore
--------------------
# --- Python ---
__pycache__/
*.pyc
*.pyo
*.pyd
.Python
env/
venv/
.env
.venv/

# --- VS Code ---
.vscode/
*.code-workspace

# --- Anki & Builds ---
# Ignora arquivos de empacotamento zip gerados
*.ankiaddon
# Ignora metadados locais que o Anki gera ao instalar manualmente
meta.json

# --- Sistema Operacional ---
.DS_Store
Thumbs.db

# --- Logs e Tempor√°rios ---
*.log
tmp/
==================================================

FILE: config.json
--------------------
{
    "acao_ao_fechar": "tray", 
    "acao_ao_minimizar": "tray",
    "sincronizar_na_bandeja": true,
    "iniciar_minimizado": false,
    "iniciar_com_sistema": false,
    "notificacoes_ativadas": true,
    "intervalo_notificacao": 30
}
==================================================

FILE: consts.py
--------------------
# -------------------------------------------------------------------------
# Copyright ¬© 2025 Caio Graco Purita. Todos os direitos reservados.
# ARQUIVO: consts.py
# -------------------------------------------------------------------------

# --- Defini√ß√£o das A√ß√µes Poss√≠veis (Constantes) ---
# Estas constantes s√£o usadas para decidir o que o programa far√° 
# ao fechar ou minimizar a janela.

# A√ß√£o: Enviar para a bandeja do sistema (perto do rel√≥gio)
ACAO_BANDEJA = "tray"

# A√ß√£o: Encerrar o aplicativo completamente
ACAO_SAIR = "quit"

# A√ß√£o: Comportamento padr√£o (ficar na barra de tarefas ou fechar normal)
ACAO_PADRAO = "standard"

# --- Textos e T√≠tulos da Aplica√ß√£o ---

# Nome oficial que aparecer√° nos menus e janelas
NOME_APP = "Anki Tray Pro"

# Texto que aparece quando passamos o mouse sobre o √≠cone na bandeja
DICA_BANDEJA = "O Anki est√° rodando em segundo plano"

# Modelo de mensagem para quando houver cart√µes (o {} ser√° substitu√≠do pelo n√∫mero)
MSG_NAO_LIDA = "Voc√™ tem {} cart√µes para revisar!"
==================================================

FILE: gui.py
--------------------
# -------------------------------------------------------------------------
# Copyright ¬© 2025 Caio Graco Purita. Todos os direitos reservados.
# ARQUIVO: gui.py
# -------------------------------------------------------------------------
import sys
import os
import winreg  # M√≥dulo para intera√ß√£o com o Registro do Windows
from aqt import mw
from aqt.qt import *
from .lang import tr
from .consts import *
from .notifications import notificador

class StartupManager:
    """
    Classe utilit√°ria respons√°vel por gerenciar a entrada do aplicativo
    no Registro do Windows, permitindo a inicializa√ß√£o autom√°tica com o sistema.
    """
    
    # Define o caminho da chave de registro para execu√ß√£o autom√°tica no usu√°rio atual
    KEY_PATH = r"Software\Microsoft\Windows\CurrentVersion\Run"
    # Define o nome interno da chave para nossa aplica√ß√£o
    APP_NAME = "AnkiTrayPro_Launcher"

    @staticmethod
    def esta_no_inicio():
        """
        Verifica se a chave de registro do aplicativo j√° existe.
        Retorna True se estiver configurado para iniciar, False caso contr√°rio.
        """
        try:
            # Tenta abrir a chave de registro em modo somente leitura
            key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, StartupManager.KEY_PATH, 0, winreg.KEY_READ)
            # Tenta ler o valor associado ao nome do aplicativo
            winreg.QueryValueEx(key, StartupManager.APP_NAME)
            # Fecha a chave ap√≥s a leitura
            winreg.CloseKey(key)
            return True
        except FileNotFoundError:
            # Retorna False se a chave ou valor n√£o existirem
            return False
        except Exception:
            # Retorna False em caso de outros erros de permiss√£o ou acesso
            return False

    @staticmethod
    def definir_inicio(ativar):
        """
        Cria ou remove a entrada no registro do Windows conforme o par√¢metro 'ativar'.
        """
        try:
            # Abre a chave de registro com permiss√£o total de acesso (leitura e escrita)
            key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, StartupManager.KEY_PATH, 0, winreg.KEY_ALL_ACCESS)
            
            if ativar:
                # Se deve ativar, obt√©m o caminho do execut√°vel Python/Anki atual
                exe_path = f'"{sys.executable}"'
                # Grava o valor no registro como uma string (REG_SZ)
                winreg.SetValueEx(key, StartupManager.APP_NAME, 0, winreg.REG_SZ, exe_path)
            else:
                # Se deve desativar, tenta excluir o valor do registro
                try:
                    winreg.DeleteValue(key, StartupManager.APP_NAME)
                except FileNotFoundError:
                    # Se o valor j√° n√£o existe, ignora o erro
                    pass
            
            # Fecha a chave de registro para efetivar as altera√ß√µes
            winreg.CloseKey(key)
        except Exception as e:
            # Em caso de erro, imprime no console (√∫til para debug)
            print(f"Erro ao configurar registro: {e}")

class DialogoConfiguracoes(QDialog):
    """
    Janela de di√°logo para configura√ß√£o das prefer√™ncias do usu√°rio.
    """
    
    def __init__(self):
        # Inicializa a classe base QDialog, definindo a janela principal como pai
        super().__init__(mw)
        # Define o t√≠tulo da janela usando a tradu√ß√£o
        self.setWindowTitle(tr("nome_menu"))
        
        # Carrega as configura√ß√µes atuais do arquivo JSON
        self.configuracao = mw.addonManager.getConfig(__name__)
        
        # Constr√≥i e organiza os widgets da interface
        self.configurar_interface()

    def configurar_interface(self):
        """
        Cria os grupos, layouts e controles da interface gr√°fica.
        """
        # Layout vertical principal que conter√° todos os grupos
        layout_principal = QVBoxLayout()

        # --- Grupo: Comportamento da Janela ---
        grupo_comportamento = QGroupBox(tr("grupo_comportamento"))
        formulario_comp = QFormLayout()

        # Cria combobox para a a√ß√£o de fechar
        self.combo_fechar = QComboBox()
        self.combo_fechar.addItem(tr("opcao_bandeja"), ACAO_BANDEJA)
        self.combo_fechar.addItem(tr("opcao_sair"), ACAO_SAIR)
        
        # Define o item selecionado com base na configura√ß√£o salva
        indice_atual = self.combo_fechar.findData(self.configuracao.get("acao_ao_fechar"))
        self.combo_fechar.setCurrentIndex(indice_atual)

        # Cria combobox para a a√ß√£o de minimizar
        self.combo_minimizar = QComboBox()
        self.combo_minimizar.addItem(tr("opcao_bandeja"), ACAO_BANDEJA)
        self.combo_minimizar.addItem(tr("opcao_padrao"), ACAO_PADRAO)
        
        # Define o item selecionado para minimizar
        indice_min = self.combo_minimizar.findData(self.configuracao.get("acao_ao_minimizar"))
        self.combo_minimizar.setCurrentIndex(indice_min)

        # Adiciona as linhas ao layout de formul√°rio
        formulario_comp.addRow(tr("lbl_fechar"), self.combo_fechar)
        formulario_comp.addRow(tr("lbl_minimizar"), self.combo_minimizar)
        
        # Define o layout do grupo
        grupo_comportamento.setLayout(formulario_comp)
        layout_principal.addWidget(grupo_comportamento)

        # --- Grupo: Sincroniza√ß√£o ---
        grupo_sinc = QGroupBox(tr("grupo_sinc"))
        layout_sinc = QVBoxLayout()
        
        # Checkbox para sincroniza√ß√£o
        self.check_sincronizar = QCheckBox(tr("chk_sincronizar"))
        self.check_sincronizar.setChecked(self.configuracao.get("sincronizar_na_bandeja"))
        
        layout_sinc.addWidget(self.check_sincronizar)
        grupo_sinc.setLayout(layout_sinc)
        layout_principal.addWidget(grupo_sinc)

        # --- Grupo: Inicializa√ß√£o ---
        grupo_inicio = QGroupBox(tr("grupo_inicio"))
        layout_inicio = QVBoxLayout()
        
        # Checkbox: Iniciar com o Windows
        # O estado inicial √© verificado diretamente no registro do sistema
        self.check_iniciar_sistema = QCheckBox(tr("chk_iniciar_sistema"))
        self.check_iniciar_sistema.setChecked(StartupManager.esta_no_inicio())
        
        # Checkbox: Iniciar minimizado
        # O estado inicial vem do arquivo de configura√ß√£o
        self.check_iniciar_min = QCheckBox(tr("chk_inicio_min"))
        self.check_iniciar_min.setChecked(self.configuracao.get("iniciar_minimizado"))
        
        # Define a depend√™ncia: s√≥ permite marcar "Iniciar Minimizado" se "Iniciar com Windows" estiver ativo
        self.check_iniciar_min.setEnabled(self.check_iniciar_sistema.isChecked())
        
        # Conecta o sinal de mudan√ßa do primeiro checkbox ao m√©todo de controle
        self.check_iniciar_sistema.toggled.connect(self.ao_alternar_inicio_sistema)
        
        # Adiciona os checkboxes ao layout
        layout_inicio.addWidget(self.check_iniciar_sistema)
        layout_inicio.addWidget(self.check_iniciar_min)
        grupo_inicio.setLayout(layout_inicio)
        layout_principal.addWidget(grupo_inicio)

        # --- Grupo: Notifica√ß√µes ---
        grupo_notificacao = QGroupBox(tr("grupo_notificacao"))
        formulario_notificacao = QFormLayout()
        
        # Checkbox para ativar notifica√ß√µes
        self.check_ativar_notif = QCheckBox(tr("chk_ativar_notif"))
        self.check_ativar_notif.setChecked(self.configuracao.get("notificacoes_ativadas"))
        
        # Campo num√©rico para o intervalo (1 a 1440 minutos)
        self.spin_intervalo = QSpinBox()
        self.spin_intervalo.setRange(1, 1440)
        self.spin_intervalo.setValue(self.configuracao.get("intervalo_notificacao"))
        
        formulario_notificacao.addRow(self.check_ativar_notif)
        formulario_notificacao.addRow(tr("lbl_intervalo"), self.spin_intervalo)
        grupo_notificacao.setLayout(formulario_notificacao)
        layout_principal.addWidget(grupo_notificacao)

        # --- Bot√µes de Confirma√ß√£o ---
        # Cria a caixa de bot√µes padr√£o (OK e Cancelar)
        botoes = QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        caixa_botoes = QDialogButtonBox(botoes)
        
        # Conecta os bot√µes aos m√©todos aceitar e rejeitar
        caixa_botoes.accepted.connect(self.ao_clicar_ok)
        caixa_botoes.rejected.connect(self.reject)
        layout_principal.addWidget(caixa_botoes)

        # Define o layout principal na janela
        self.setLayout(layout_principal)

    def ao_alternar_inicio_sistema(self, marcado):
        """
        Executado quando o usu√°rio altera o checkbox 'Iniciar com Windows'.
        Habilita ou desabilita o checkbox dependente 'Iniciar Minimizado'.
        """
        # Habilita ou desabilita o segundo checkbox
        self.check_iniciar_min.setEnabled(marcado)
        
        # Se o usu√°rio desmarcar o in√≠cio com o sistema, desmarca automaticamente o in√≠cio minimizado
        if not marcado:
            self.check_iniciar_min.setChecked(False)

    def ao_clicar_ok(self):
        """
        Executado ao clicar em OK. Salva todas as configura√ß√µes e fecha a janela.
        """
        
        # Atualiza o dicion√°rio de configura√ß√£o com os dados dos widgets
        self.configuracao["acao_ao_fechar"] = self.combo_fechar.currentData()
        self.configuracao["acao_ao_minimizar"] = self.combo_minimizar.currentData()
        self.configuracao["sincronizar_na_bandeja"] = self.check_sincronizar.isChecked()
        self.configuracao["iniciar_minimizado"] = self.check_iniciar_min.isChecked()
        self.configuracao["notificacoes_ativadas"] = self.check_ativar_notif.isChecked()
        self.configuracao["intervalo_notificacao"] = self.spin_intervalo.value()

        # Escreve as configura√ß√µes no arquivo JSON do addon
        mw.addonManager.writeConfig(__name__, self.configuracao)
        
        # Chama o gerenciador para aplicar a altera√ß√£o no Registro do Windows
        StartupManager.definir_inicio(self.check_iniciar_sistema.isChecked())

        # Reinicia o temporizador de notifica√ß√µes para refletir poss√≠veis mudan√ßas de intervalo
        notificador.iniciar_temporizador()
        
        # Fecha a janela de di√°logo com resultado positivo
        self.accept()

def mostrar_configuracoes():
    """
    Fun√ß√£o auxiliar para instanciar e exibir a janela de configura√ß√µes.
    """
    dialogo = DialogoConfiguracoes()
    dialogo.exec()
==================================================

FILE: LICENSE
--------------------
MIT License

Copyright (c) 2025 Caio Graco Purita

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
==================================================

FILE: manifest.json
--------------------
{
    "name": "Anki Tray Pro: Minimizar, Sincronizar & Notificar",
    "package": "AnkiTrayPro",
    "conflicts": [],
    "mod": 1678900000
}
==================================================

FILE: meta.json
--------------------
{"config": {"acao_ao_fechar": "tray", "acao_ao_minimizar": "tray", "sincronizar_na_bandeja": true, "iniciar_minimizado": false, "iniciar_com_sistema": false, "notificacoes_ativadas": true, "intervalo_notificacao": 30}}
==================================================

FILE: notifications.py
--------------------
# -------------------------------------------------------------------------
# Copyright ¬© 2025 Caio Graco Purita. Todos os direitos reservados.
# ARQUIVO: notifications.py
# -------------------------------------------------------------------------
from aqt import mw
from aqt.qt import *
from .lang import tr

class GerenciadorNotificacao:
    """
    Controla um temporizador para verificar periodicamente cart√µes vencidos
    e emitir alertas quando o Anki estiver minimizado.
    """
    def __init__(self):
        self.temporizador = QTimer(mw)
        self.temporizador.timeout.connect(self.verificar_cartoes_vencidos)
        self.iniciar_temporizador()

    def iniciar_temporizador(self):
        """L√™ as configura√ß√µes e inicia ou para o ciclo de verifica√ß√£o."""
        configuracao = mw.addonManager.getConfig(__name__)
        
        if configuracao.get("notificacoes_ativadas"):
            # Converte o intervalo de minutos para milissegundos
            intervalo_ms = configuracao.get("intervalo_notificacao", 30) * 60 * 1000
            self.temporizador.start(intervalo_ms)
        else:
            self.temporizador.stop()

    def verificar_cartoes_vencidos(self):
        """Consulta a cole√ß√£o do Anki para contar revis√µes pendentes."""
        
        # N√£o notifica se a janela estiver vis√≠vel para o usu√°rio
        if mw.isVisible():
            return

        try:
            # Obt√©m a contagem: (novos, aprendizado, revis√£o)
            contagens = mw.col.sched.counts()
            # Considera apenas aprendizado e revis√£o para o alerta
            total_pendente = contagens[1] + contagens[2]
        except:
            # Tratamento de erro caso a API do agendador n√£o esteja dispon√≠vel
            total_pendente = 0

        if total_pendente > 0:
            self.mostrar_notificacao(total_pendente)

    def mostrar_notificacao(self, quantidade):
        """Emite sinal sonoro e exibe bal√£o na bandeja."""
        
        # Emite som padr√£o do sistema
        QApplication.beep()
        
        # Importa o gerenciador de bandeja localmente para acessar o √≠cone
        from .tray import gerenciador_bandeja
        if gerenciador_bandeja.icone_bandeja:
            mensagem = tr("msg_vencidos").format(quantidade)
            
            # Exibe a mensagem flutuante com √≠cone de informa√ß√£o
            gerenciador_bandeja.icone_bandeja.showMessage(
                "Anki", 
                mensagem, 
                QSystemTrayIcon.MessageIcon.Information, 
                5000
            )

# Inst√¢ncia global
notificador = GerenciadorNotificacao()
==================================================

FILE: README.md
--------------------
# Anki Tray Pro üì•

> **Minimize o Anki para a bandeja, receba notifica√ß√µes de estudos e mantenha seu fluxo focado.**

O **Anki Tray Pro** √© um add-on projetado para quem estuda durante o dia todo e precisa que o Anki fique "invis√≠vel", mas acess√≠vel. Ele permite minimizar o aplicativo para a bandeja do sistema (perto do rel√≥gio), sincronizar automaticamente ao esconder e notificar quando houver revis√µes pendentes.

---

## üì• Instala√ß√£o

### Via AnkiWeb
1. Abra o Anki e v√° em **Ferramentas** -> **Complementos** (Add-ons).
2. Clique em **Obter Complementos**.
3. Cole o c√≥digo abaixo:

```text
(C√ìDIGO_DO_ANKIWEB_AQUI)
```

### Instala√ß√£o Manual (Desenvolvedor)
1. Baixe este reposit√≥rio ou clone via Git.
2. Copie a pasta `AnkiTrayPro` para dentro da pasta `addons21` do seu Anki.
3. Reinicie o Anki.

---

## ‚ú® Recursos Principais

| Funcionalidade | Descri√ß√£o |
| :--- | :--- |
| **Minimizar para a Bandeja** | Ao clicar no **X** ou minimizar, o Anki vai para o √≠cone perto do rel√≥gio (Tray) em vez de fechar. |
| **Sincroniza√ß√£o Autom√°tica** | Configure para sincronizar seus decks toda vez que o Anki for enviado para a bandeja. |
| **Notifica√ß√µes de Estudo** | Receba um alerta visual e sonoro discreto a cada X minutos se houver cart√µes vencidos. |
| **Inicializa√ß√£o Silenciosa** | Op√ß√£o para iniciar o Anki j√° minimizado (√∫til para iniciar junto com o sistema). |
| **Totalmente em Portugu√™s** | Interface e configura√ß√µes nativas em PT-BR. |

---

## ‚öôÔ∏è Configura√ß√£o

Acesse o menu **Ferramentas** -> **Op√ß√µes do Anki Tray Pro** para personalizar:

### 1. Comportamento da Janela
* **Ao clicar no 'X' (Fechar):** Escolha entre enviar para a bandeja (padr√£o) ou fechar o programa realmente.
* **Ao minimizar (_):** Escolha se o bot√£o de minimizar padr√£o do Windows deve enviar para a bandeja ou manter na barra de tarefas.

### 2. Sincroniza√ß√£o
* **Sincronizar ao enviar para o Tray:** Garante que seus dados estejam salvos na nuvem sempre que voc√™ "esconder" o Anki.

### 3. Notifica√ß√µes
* Defina se quer ser avisado sobre revis√µes e escolha o **intervalo de verifica√ß√£o** (em minutos).
* *Nota:* As notifica√ß√µes s√≥ aparecem se o Anki estiver minimizado na bandeja, para n√£o incomodar enquanto voc√™ j√° estuda.

---

## üõ†Ô∏è Tecnologias

* **Python 3.9+**
* **Qt6 / PyQt6** (Interface Gr√°fica do Anki)

---

## ¬© Direitos Autorais e Licen√ßa

**Copyright ¬© 2025 Caio Graco Purita.**
Todos os direitos reservados.

Este projeto foi desenvolvido para facilitar a rotina de estudos cont√≠nuos.
==================================================

FILE: tray.py
--------------------
# -------------------------------------------------------------------------
# Copyright ¬© 2025 Caio Graco Purita.
# Todos os direitos reservados.
# ARQUIVO: tray.py
# -------------------------------------------------------------------------
from aqt import mw
from aqt.qt import *
from .consts import *

class GerenciadorBandeja:
    """
    Gerencia a intera√ß√£o com a bandeja do sistema (System Tray) e intercepta
    eventos de janela para alterar o comportamento de fechar/minimizar.
    """
    def __init__(self):
        # Inicializa a vari√°vel que guardar√° a refer√™ncia ao √≠cone
        self.icone_bandeja = None
        
        # Instala os ganchos (hooks) nos eventos da janela principal do Anki
        self.configurar_ganchos()
        
        # Configura o aspecto visual do √≠cone e seus menus
        self.configurar_icone_bandeja()

    def obter_config(self, chave):
        """
        Acessa o gerenciador de addons do Anki para ler uma configura√ß√£o salva.
        Retorna o valor associado √† chave solicitada.
        """
        return mw.addonManager.getConfig(__name__).get(chave)

    def configurar_icone_bandeja(self):
        """
        Cria o objeto QSystemTrayIcon, define o √≠cone visual e constr√≥i
        o menu de contexto que aparece ao clicar com o bot√£o direito.
        """
        
        # Verifica se o √≠cone j√° existe para evitar recria√ß√£o desnecess√°ria
        if self.icone_bandeja:
            return

        # Cria a inst√¢ncia do √≠cone de bandeja associada √† janela principal
        self.icone_bandeja = QSystemTrayIcon(mw)
        
        # Utiliza o pr√≥prio √≠cone da janela do Anki para manter a consist√™ncia visual
        self.icone_bandeja.setIcon(mw.windowIcon())
        
        # Define o texto que aparece quando o mouse repousa sobre o √≠cone
        self.icone_bandeja.setToolTip(DICA_BANDEJA)
        
        # Cria o menu de contexto (clique com bot√£o direito)
        menu = QMenu()
        
        # Cria a a√ß√£o para restaurar a janela principal
        acao_mostrar = QAction("Abrir Anki", menu)
        # Conecta o disparo da a√ß√£o ao m√©todo que mostra a janela
        acao_mostrar.triggered.connect(self.mostrar_janela)
        # Adiciona a a√ß√£o ao menu
        menu.addAction(acao_mostrar)
        
        # Cria a a√ß√£o para for√ßar a sincroniza√ß√£o
        acao_sinc = QAction("Sincronizar", menu)
        # Conecta diretamente ao m√©todo nativo de sincroniza√ß√£o do Anki
        acao_sinc.triggered.connect(lambda: mw.onSync())
        # Adiciona a a√ß√£o ao menu
        menu.addAction(acao_sinc)

        # Adiciona uma linha separadora visual no menu
        menu.addSeparator()

        # Cria a a√ß√£o para encerrar o aplicativo completamente
        acao_sair = QAction("Sair Totalmente", menu)
        # Conecta ao m√©todo que fecha o programa
        acao_sair.triggered.connect(self.forcar_saida)
        # Adiciona a a√ß√£o ao menu
        menu.addAction(acao_sair)

        # Atribui o menu criado ao √≠cone da bandeja
        self.icone_bandeja.setContextMenu(menu)
        
        # Conecta o evento de clique (esquerdo ou duplo) ao tratador de cliques
        self.icone_bandeja.activated.connect(self.ao_clicar_icone)

    def ao_clicar_icone(self, razao):
        """
        Recebe o motivo (reason) do clique no √≠cone.
        Se for um clique de ativa√ß√£o (geralmente clique simples), restaura a janela.
        """
        if razao == QSystemTrayIcon.ActivationReason.Trigger:
            self.mostrar_janela()

    def mostrar_janela(self):
        """
        Traz a janela do Anki de volta para a tela, restaura se estiver minimizada
        e coloca o foco nela.
        """
        # Torna a janela vis√≠vel
        mw.show()
        
        # Obt√©m o estado atual da janela
        estado_atual = mw.windowState()
        
        # Remove a flag de 'Minimizado' e adiciona a flag de 'Ativo'
        mw.setWindowState(estado_atual & ~Qt.WindowState.WindowMinimized | Qt.WindowState.WindowActive)
        
        # Solicita ativa√ß√£o da janela ao sistema operacional
        mw.activateWindow()
        # Traz a janela para o topo da pilha de janelas
        mw.raise_()
        
        # Oculta o √≠cone da bandeja, pois a janela principal j√° est√° vis√≠vel
        if self.icone_bandeja:
            self.icone_bandeja.hide()

    def esconder_para_bandeja(self):
        """
        Realiza o procedimento de esconder o Anki: executa sincronia (se configurado),
        mostra o √≠cone na bandeja e oculta a janela principal.
        """
        
        # Verifica na configura√ß√£o se deve sincronizar antes de esconder
        if self.obter_config("sincronizar_na_bandeja"):
            mw.onSync()

        # Garante que o √≠cone da bandeja esteja vis√≠vel antes de sumir com a janela
        if self.icone_bandeja:
            self.icone_bandeja.show()
        
        # Oculta a janela principal do Anki
        mw.hide()
        
        # Exibe um bal√£o de notifica√ß√£o informando que o programa continua rodando
        if self.icone_bandeja:
            self.icone_bandeja.showMessage(
                NOME_APP, 
                "Minimizado para a bandeja.", 
                QSystemTrayIcon.MessageIcon.Information, 
                1000
            )

    def forcar_saida(self):
        """
        Encerra a inst√¢ncia da aplica√ß√£o Qt, fechando o Anki definitivamente.
        """
        mw.app.quit()

    # --- Tratamento de Eventos (Hooks) ---

    def configurar_ganchos(self):
        """
        Substitui os m√©todos originais de evento da janela principal (mw) pelos
        m√©todos personalizados desta classe.
        """
        # Salva refer√™ncia ao evento de fechar original
        self.evento_fechar_original = mw.closeEvent
        # Substitui pelo nosso m√©todo
        mw.closeEvent = self.ao_evento_fechar
        
        # Salva refer√™ncia ao evento de mudan√ßa de estado original
        self.evento_mudanca_original = mw.changeEvent
        # Substitui pelo nosso m√©todo
        mw.changeEvent = self.ao_evento_mudanca

    def ao_evento_fechar(self, evento):
        """
        Intercepta o evento de fechamento da janela (bot√£o X ou Alt+F4).
        """
        # L√™ a configura√ß√£o para saber qual a√ß√£o tomar
        acao = self.obter_config("acao_ao_fechar")
        
        if acao == ACAO_BANDEJA:
            # Ignora o pedido de fechamento do sistema
            evento.ignore()
            # Executa a rotina de minimizar para a bandeja
            self.esconder_para_bandeja()
        else:
            # Se a a√ß√£o for sair ou padr√£o, repassa para o tratamento original do Anki
            self.evento_fechar_original(evento)

    def ao_evento_mudanca(self, evento):
        """
        Intercepta eventos de mudan√ßa de estado da janela (ex: minimizar, maximizar).
        """
        # Verifica se o tipo de evento √© uma mudan√ßa de estado da janela
        if evento.type() == QEvent.Type.WindowStateChange:
            # Verifica se o novo estado inclui a flag de minimizado
            if mw.windowState() & Qt.WindowState.WindowMinimized:
                # L√™ a configura√ß√£o do usu√°rio para minimiza√ß√£o
                acao = self.obter_config("acao_ao_minimizar")
                
                if acao == ACAO_BANDEJA:
                    # Agenda a execu√ß√£o do escondimento para o pr√≥ximo ciclo do loop de eventos.
                    # Isso permite que o sistema operacional conclua anima√ß√µes pendentes.
                    QTimer.singleShot(50, self.esconder_para_bandeja)
        
        # Chama o tratador original para garantir que outras mudan√ßas funcionem normalmente
        self.evento_mudanca_original(evento)

# Instancia o gerenciador globalmente para que inicie junto com o m√≥dulo
gerenciador_bandeja = GerenciadorBandeja()
==================================================

FILE: __init__.py
--------------------
# -------------------------------------------------------------------------
# Copyright ¬© 2025 Caio Graco Purita. Todos os direitos reservados.
# ARQUIVO: __init__.py
# -------------------------------------------------------------------------
from aqt import mw
from aqt.qt import *
from aqt import gui_hooks # Ganchos do Anki (hooks)

# Importa nossos m√≥dulos (note que as vari√°veis agora est√£o em portugu√™s)
from .tray import gerenciador_bandeja
from .gui import mostrar_configuracoes
from .lang import tr
from .notifications import notificador

def ao_carregar_perfil():
    """
    Executado assim que o perfil do usu√°rio √© carregado.
    Verifica se o usu√°rio configurou para iniciar o Anki escondido.
    """
    configuracao = mw.addonManager.getConfig(__name__)
    
    if configuracao.get("iniciar_minimizado"):
        gerenciador_bandeja.esconder_para_bandeja()

def configurar_menu():
    """Adiciona a op√ß√£o de configura√ß√£o no menu 'Ferramentas' do Anki."""
    
    # Cria a a√ß√£o no menu com o texto traduzido
    acao = QAction(tr("nome_menu"), mw)

        # Conecta o clique √† fun√ß√£o que abre a janela
    acao.triggered.connect(mostrar_configuracoes)

        # Adiciona a a√ß√£o ao menu Tools (Ferramentas) da janela principal
    mw.form.menuTools.addAction(acao)
    
# --- Registro dos Ganchos (Start) ---

# Adiciona nossa fun√ß√£o √† lista de coisas a fazer quando o perfil abrir
gui_hooks.profile_did_open.append(ao_carregar_perfil)

# Configura o menu imediatamente
configurar_menu()
==================================================

FILE: lang\en.py
--------------------
# English Translations

traducoes = {
    "nome_menu": "Anki Tray Pro Options",
    "grupo_comportamento": "Window Behavior",
    "lbl_fechar": "On 'X' (Close) click:",
    "lbl_minimizar": "On minimize (-):",
    "opcao_bandeja": "Minimize to Tray",
    "opcao_sair": "Quit Anki",
    "opcao_padrao": "Standard (Taskbar)",
    "grupo_sinc": "Synchronization",
    "chk_sincronizar": "Sync before minimizing to tray",
    "grupo_inicio": "Startup",
    "chk_iniciar_sistema": "Start Anki with Windows",
    "chk_inicio_min": "Start Anki minimized to tray",
    "grupo_notificacao": "Notifications",
    "chk_ativar_notif": "Enable due card notifications",
    "lbl_intervalo": "Check every (minutes):",
    "msg_vencidos": "You have {} cards due!",
    "dica_bandeja": "Anki is running in background"
}
==================================================

FILE: lang\pt.py
--------------------
# Tradu√ß√µes em Portugu√™s
# A vari√°vel deve se chamar 'traducoes' para o __init__.py encontrar.
traducoes = {
    "nome_menu": "Op√ß√µes do Anki Tray Pro",
    "grupo_comportamento": "Comportamento da Janela",
    "lbl_fechar": "Ao clicar no 'X' (Fechar):",
    "lbl_minimizar": "Ao minimizar (-):",
    "opcao_bandeja": "Ir para a Bandeja (Tray)",
    "opcao_sair": "Sair do Anki",
    "opcao_padrao": "Padr√£o (Barra de Tarefas)",
    "grupo_sinc": "Sincroniza√ß√£o",
    "chk_sincronizar": "Sincronizar ao enviar para o Tray",
    "grupo_inicio": "Inicializa√ß√£o",
    "chk_iniciar_sistema": "Iniciar Anki junto com o Windows",
    "chk_inicio_min": "Iniciar o Anki minimizado na bandeja",
    "grupo_notificacao": "Notifica√ß√µes",
    "chk_ativar_notif": "Ativar notifica√ß√µes de revis√£o",
    "lbl_intervalo": "Verificar a cada (minutos):",
    "msg_vencidos": "Voc√™ tem {} cart√µes para revisar!",
    "dica_bandeja": "Anki est√° rodando em segundo plano"
}
==================================================

FILE: lang\__init__.py
--------------------
# -------------------------------------------------------------------------
# Copyright ¬© 2025 Caio Graco Purita. Todos os direitos reservados.
# ARQUIVO: lang/__init__.py
# -------------------------------------------------------------------------
import importlib
from aqt import mw  # Importa a janela principal do Anki para acessar configura√ß√µes

# Vari√°vel global para armazenar as tradu√ß√µes carregadas na mem√≥ria.
# Funciona como um "cache" para n√£o ler arquivos toda vez.
_traducoes_atuais = {}

def carregar_traducoes():
    """
    Descobre o idioma do Anki e carrega o arquivo de tradu√ß√£o correspondente 
    (pt.py, en.py etc.) para a mem√≥ria.
    """
    global _traducoes_atuais
    
    # Se o dicion√°rio j√° estiver preenchido, n√£o precisamos fazer nada (retorna).
    if _traducoes_atuais:
        return

    # 1. Obt√©m o c√≥digo de idioma configurado no Anki (ex: 'pt_BR', 'en_US', 'es_ES')
    # Se n√£o encontrar, assume 'en' (ingl√™s) como padr√£o.
    codigo_idioma = mw.pm.meta.get("defaultLang", "en")
    
    # 2. Pega apenas as duas primeiras letras para simplificar (ex: 'pt' de 'pt_BR')
    idioma_curto = codigo_idioma[:2]

    # 3. Tenta importar o m√≥dulo de tradu√ß√£o dinamicamente
    try:
        # Tenta carregar: .pt, .en, etc. dentro deste pacote (package=__name__)
        modulo = importlib.import_module(f".{idioma_curto}", package=__name__)
        
        # Se der certo, pega o dicion√°rio 'traducoes' de dentro do arquivo
        _traducoes_atuais = modulo.traducoes
        
    except ImportError:
        # Se der erro (ex: o arquivo 'fr.py' n√£o existe), usamos o Ingl√™s como seguran√ßa (fallback)
        try:
            modulo = importlib.import_module(".en", package=__name__)
            _traducoes_atuais = modulo.traducoes
        except ImportError:
            # Caso extremo: nem o arquivo en.py existe. Deixamos vazio.
            _traducoes_atuais = {}

def tr(chave):
    """
    Fun√ß√£o principal de tradu√ß√£o.
    Recebe uma 'chave' (string) e retorna o texto traduzido.
    """
    # Garante que as tradu√ß√µes foram carregadas antes de procurar
    if not _traducoes_atuais:
        carregar_traducoes()
    
    # Tenta buscar a chave no dicion√°rio. 
    # Se n√£o achar, retorna a pr√≥pria chave entre colchetes para alertar que falta tradu√ß√£o.
    return _traducoes_atuais.get(chave, f"[{chave}]")
==================================================

FILE: templates\ide\vscode\settings.json
--------------------
{
    "files.autoSave": "afterDelay",
    "editor.formatOnSave": true,
    "editor.rulers": [88, 120],
    "editor.tabSize": 4,
    "editor.insertSpaces": true,

    "[python]": {
        "editor.defaultFormatter": "ms-python.black-formatter",
        "editor.formatOnSave": true,
        "editor.codeActionsOnSave": {
            "source.organizeImports": "explicit"
        }
    },

    "files.exclude": {
        "**/.git": true,
        "**/.svn": true,
        "**/.hg": true,
        "**/CVS": true,
        "**/.DS_Store": true,
        "**/Thumbs.db": true,
        "**/__pycache__": true,
        "**/*.pyc": true,
        "**/*.pyo": true,
        "**/*.pyd": true,
        ".venv": true,
        ".pytest_cache": true,
        ".mypy_cache": true
    },

    "python.analysis.typeCheckingMode": "basic",
    "python.analysis.autoImportCompletions": true
}
==================================================

FILE: templates\legal\CABE√áALHO_PROPRIETARIO.txt
--------------------
# -------------------------------------------------------------------------
# Copyright ¬© 2025 Caio Graco Purita. Todos os direitos reservados.
#
# Este arquivo √© parte integrante de um software propriet√°rio.
# A c√≥pia, distribui√ß√£o, modifica√ß√£o ou engenharia reversa n√£o autorizadas
# s√£o estritamente proibidas.
#
# Para permiss√µes de uso ou colabora√ß√£o, contacte o autor.
# -------------------------------------------------------------------------

==================================================

