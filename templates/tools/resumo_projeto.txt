=== RAIO-X DO PROJETO: AnkiTrayPro ===
Gerado em: 2026-01-10 03:48:18.237661
Copyright ¬© 2025 Caio Graco Purita
==================================================

--- ESTRUTURA DE ARQUIVOS ---
[AnkiTrayPro/]
    .gitattributes
    .gitignore
    config.json
    consts.py
    gui.py
    LICENSE
    manifest.json
    meta.json
    notifications.py
    README.md
    tray.py
    __init__.py
    [lang/]
        en.py
        pt.py
        __init__.py
    [templates/]
        [ide/]
            [vscode/]
                settings.json
        [legal/]
            CABE√áALHO_PROPRIETARIO.txt
        [tools/]

==================================================

--- CONTE√öDO DOS ARQUIVOS ---

FILE: .gitattributes
--------------------
# Auto detect text files and perform LF normalization
* text=auto

==================================================

FILE: .gitignore
--------------------
# --- Python ---
__pycache__/
*.pyc
*.pyo
*.pyd
.Python
env/
venv/
.env
.venv/

# --- VS Code ---
.vscode/
*.code-workspace

# --- Anki & Builds ---
# Ignora arquivos de empacotamento zip gerados
*.ankiaddon
# Ignora metadados locais que o Anki gera ao instalar manualmente
meta.json

# --- Sistema Operacional ---
.DS_Store
Thumbs.db

# --- Logs e Tempor√°rios ---
*.log
tmp/
==================================================

FILE: config.json
--------------------
{
    "acao_ao_fechar": "tray", 
    "acao_ao_minimizar": "tray",
    "sincronizar_na_bandeja": true,
    "iniciar_minimizado": false,
    "iniciar_com_sistema": false,
    "notificacoes_ativadas": true,
    "intervalo_notificacao": 30
}
==================================================

FILE: consts.py
--------------------
# -------------------------------------------------------------------------
# Copyright ¬© 2025 Caio Graco Purita. Todos os direitos reservados.
# ARQUIVO: consts.py
# -------------------------------------------------------------------------

# --- Defini√ß√£o das A√ß√µes Poss√≠veis (Constantes) ---
# Estas constantes s√£o usadas para decidir o que o programa far√° 
# ao fechar ou minimizar a janela.

# A√ß√£o: Enviar para a bandeja do sistema (perto do rel√≥gio)
ACAO_BANDEJA = "tray"

# A√ß√£o: Encerrar o aplicativo completamente
ACAO_SAIR = "quit"

# A√ß√£o: Comportamento padr√£o (ficar na barra de tarefas ou fechar normal)
ACAO_PADRAO = "standard"

# --- Textos e T√≠tulos da Aplica√ß√£o ---

# Nome oficial que aparecer√° nos menus e janelas
NOME_APP = "Anki Tray Pro"

# Texto que aparece quando passamos o mouse sobre o √≠cone na bandeja
DICA_BANDEJA = "O Anki est√° rodando em segundo plano"

# Modelo de mensagem para quando houver cart√µes (o {} ser√° substitu√≠do pelo n√∫mero)
MSG_NAO_LIDA = "Voc√™ tem {} cart√µes para revisar!"
==================================================

FILE: gui.py
--------------------
# -------------------------------------------------------------------------
# Copyright ¬© 2025 Caio Graco Purita. Todos os direitos reservados.
# ARQUIVO: gui.py
# -------------------------------------------------------------------------

# Importa m√≥dulos do sistema para manipula√ß√£o de arquivos e caminhos
import sys
import os
# Importa m√≥dulo para execu√ß√£o de subprocessos (necess√°rio para criar o atalho)
import subprocess
# Importa m√≥dulo para ler o Registro do Windows
import winreg

# Importa a janela principal do Anki
from aqt import mw
# Importa os componentes gr√°ficos da biblioteca Qt
from aqt.qt import *
# Importa fun√ß√µes utilit√°rias para exibir alertas (apenas em caso de erro)
from aqt.utils import showWarning

# Importa a fun√ß√£o de tradu√ß√£o interna
from .lang import tr
# Importa as constantes globais
from .consts import *
# Importa o gerenciador de notifica√ß√µes
from .notifications import notificador

# Classe respons√°vel por gerenciar a inicializa√ß√£o autom√°tica do Anki
class StartupManager:
    """
    Gerencia a cria√ß√£o do atalho na pasta de inicializa√ß√£o PADR√ÉO do Windows.
    Vers√£o final limpa: sem logs, sem debug, execu√ß√£o silenciosa.
    """
    
    # Define o nome do arquivo de atalho que ser√° criado
    SHORTCUT_NAME = "AnkiTrayPro_AutoStart.lnk"

    # M√©todo est√°tico para localizar a pasta de inicializa√ß√£o padr√£o do usu√°rio
    @staticmethod
    def _obter_pasta_startup():
        # Obt√©m o caminho da pasta AppData (Roaming)
        appdata = os.getenv('APPDATA')
        
        # Constr√≥i o caminho padr√£o do Windows: 
        # ...\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup
        return os.path.join(appdata, r'Microsoft\Windows\Start Menu\Programs\Startup')

    # M√©todo est√°tico para obter o caminho completo do arquivo .lnk
    @staticmethod
    def _obter_caminho_atalho():
        # Retorna o caminho completo final do atalho dentro da pasta Startup
        return os.path.join(StartupManager._obter_pasta_startup(), StartupManager.SHORTCUT_NAME)

    # Verifica se o atalho j√° existe no disco (usado para marcar o checkbox)
    @staticmethod
    def esta_no_inicio():
        return os.path.exists(StartupManager._obter_caminho_atalho())

    # M√©todo auxiliar para ler o Registro do Windows
    @staticmethod
    def _buscar_caminho_registro():
        """
        Tenta descobrir onde o Anki foi instalado consultando o Registro.
        √ötil quando rodamos via Python e n√£o sabemos onde est√° o 'anki.exe'.
        """
        # Lista de chaves poss√≠veis onde o Anki pode ter gravado a instala√ß√£o
        caminhos_registro = [
            (winreg.HKEY_CURRENT_USER, r"Software\Microsoft\Windows\CurrentVersion\Uninstall\Anki"),
            (winreg.HKEY_LOCAL_MACHINE, r"Software\Microsoft\Windows\CurrentVersion\Uninstall\Anki"),
            (winreg.HKEY_LOCAL_MACHINE, r"Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\Anki")
        ]

        # Itera sobre as chaves poss√≠veis
        for hkey, subkey in caminhos_registro:
            try:
                with winreg.OpenKey(hkey, subkey) as chave_aberta:
                    # L√™ o valor "InstallLocation"
                    pasta_instalacao, _ = winreg.QueryValueEx(chave_aberta, "InstallLocation")
                    caminho_exe = os.path.join(pasta_instalacao, "anki.exe")
                    
                    # Verifica se o arquivo realmente existe l√°
                    if os.path.exists(caminho_exe):
                        return caminho_exe
            except:
                # Ignora erros e tenta a pr√≥xima chave
                continue
        
        return None

    # M√©todo Principal de Detec√ß√£o do Execut√°vel
    @staticmethod
    def _obter_executavel_anki():
        """
        Define qual arquivo .exe o atalho deve abrir.
        """
        caminho_atual = os.path.abspath(sys.executable)
        nome_exe = os.path.basename(caminho_atual).lower()

        # 1. Se n√£o for python (ex: anki.exe), confiamos nele.
        if "python" not in nome_exe:
            return caminho_atual

        # 2. Se for Python (ambiente dev/venv), buscamos no Registro.
        caminho_registro = StartupManager._buscar_caminho_registro()
        if caminho_registro:
            return caminho_registro

        # 3. Fallback: Busca em pastas padr√£o do sistema
        locais_padrao = [
            os.path.join(os.getenv('LOCALAPPDATA'), r"Programs\Anki\anki.exe"),
            os.path.join(os.getenv('ProgramFiles'), r"Anki\anki.exe"),
            os.path.join(os.getenv('ProgramFiles(x86)'), r"Anki\anki.exe")
        ]

        for caminho in locais_padrao:
            if caminho and os.path.exists(caminho):
                return caminho

        # 4. √öltimo recurso: Usa o pr√≥prio Python
        return caminho_atual

    # Cria√ß√£o do Atalho via VBScript
    @staticmethod
    def criar_atalho(caminho_exe, caminho_link):
        try:
            pasta_link = os.path.dirname(caminho_link)
            
            # Garante que a pasta existe
            if not os.path.exists(pasta_link):
                os.makedirs(pasta_link)

            # Argumentos: Se cairmos no fallback do Python, precisamos de '-m aqt'
            args = ""
            if "python" in os.path.basename(caminho_exe).lower():
                args = "-m aqt"

            # Script VBS para criar o arquivo .lnk
            script_vbs = f"""
            Set oWS = WScript.CreateObject("WScript.Shell")
            sLinkFile = "{caminho_link}"
            Set oLink = oWS.CreateShortcut(sLinkFile)
            oLink.TargetPath = "{caminho_exe}"
            oLink.Arguments = "{args}"
            oLink.WorkingDirectory = "{os.path.dirname(caminho_exe)}"
            oLink.WindowStyle = 1
            oLink.Description = "Iniciado automaticamente pelo Anki Tray Pro"
            oLink.Save
            """
            
            # Salva script tempor√°rio na pasta TEMP
            caminho_vbs = os.path.join(os.getenv('TEMP'), "anki_shortcut_gen.vbs")
            with open(caminho_vbs, "w", encoding="utf-8") as file:
                file.write(script_vbs)
            
            # Localiza o cscript
            cscript_path = os.path.join(os.getenv('SystemRoot'), "System32", "cscript.exe")
            
            # Executa o script silenciosamente
            CREATE_NO_WINDOW = 0x08000000
            subprocess.run(
                [cscript_path, '//Nologo', caminho_vbs],
                check=True,
                creationflags=CREATE_NO_WINDOW
            )
            
            # Limpa tempor√°rio
            if os.path.exists(caminho_vbs):
                os.remove(caminho_vbs)

        except Exception as e:
            # S√≥ repassa o erro se realmente falhar
            raise e

    # M√©todo externo chamado pela GUI
    @staticmethod
    def definir_inicio(ativar):
        try:
            caminho_atalho = StartupManager._obter_caminho_atalho()
            
            if ativar:
                # Descobre o execut√°vel correto
                exe_alvo = StartupManager._obter_executavel_anki()
                
                # Cria o atalho (sem logs, sem popups)
                StartupManager.criar_atalho(exe_alvo, caminho_atalho)
                
            else:
                # Remove o atalho
                if os.path.exists(caminho_atalho):
                    os.remove(caminho_atalho)
            
        except Exception as e:
            # Em caso de erro cr√≠tico, mostra um aviso visual simples
            showWarning(f"Erro ao configurar inicializa√ß√£o:\n{str(e)}")

# Janela de Configura√ß√µes
class DialogoConfiguracoes(QDialog):
    """
    Interface gr√°fica para o usu√°rio alterar as prefer√™ncias do Add-on.
    """
    def __init__(self):
        super().__init__(mw)
        self.setWindowTitle(tr("nome_menu"))
        self.configuracao = mw.addonManager.getConfig(__name__)
        self.configurar_interface()

    def configurar_interface(self):
        layout_principal = QVBoxLayout()

        # --- Grupo: Comportamento ---
        grupo_comportamento = QGroupBox(tr("grupo_comportamento"))
        formulario_comp = QFormLayout()

        self.combo_fechar = QComboBox()
        self.combo_fechar.addItem(tr("opcao_bandeja"), ACAO_BANDEJA)
        self.combo_fechar.addItem(tr("opcao_sair"), ACAO_SAIR)
        
        indice_atual = self.combo_fechar.findData(self.configuracao.get("acao_ao_fechar"))
        self.combo_fechar.setCurrentIndex(indice_atual)

        formulario_comp.addRow(tr("lbl_fechar"), self.combo_fechar)
        grupo_comportamento.setLayout(formulario_comp)
        layout_principal.addWidget(grupo_comportamento)

        # --- Grupo: Sincroniza√ß√£o ---
        grupo_sinc = QGroupBox(tr("grupo_sinc"))
        layout_sinc = QVBoxLayout()
        self.check_sincronizar = QCheckBox(tr("chk_sincronizar"))
        self.check_sincronizar.setChecked(self.configuracao.get("sincronizar_na_bandeja"))
        layout_sinc.addWidget(self.check_sincronizar)
        grupo_sinc.setLayout(layout_sinc)
        layout_principal.addWidget(grupo_sinc)

        # --- Grupo: Inicializa√ß√£o ---
        grupo_inicio = QGroupBox(tr("grupo_inicio"))
        layout_inicio = QVBoxLayout()
        self.check_iniciar_sistema = QCheckBox(tr("chk_iniciar_sistema"))
        self.check_iniciar_sistema.setChecked(StartupManager.esta_no_inicio())
        
        self.check_iniciar_min = QCheckBox(tr("chk_inicio_min"))
        self.check_iniciar_min.setChecked(self.configuracao.get("iniciar_minimizado"))
        self.check_iniciar_min.setEnabled(self.check_iniciar_sistema.isChecked())
        self.check_iniciar_sistema.toggled.connect(self.ao_alternar_inicio_sistema)
        
        layout_inicio.addWidget(self.check_iniciar_sistema)
        layout_inicio.addWidget(self.check_iniciar_min)
        grupo_inicio.setLayout(layout_inicio)
        layout_principal.addWidget(grupo_inicio)

        # --- Grupo: Notifica√ß√µes ---
        grupo_notificacao = QGroupBox(tr("grupo_notificacao"))
        formulario_notificacao = QFormLayout()
        self.check_ativar_notif = QCheckBox(tr("chk_ativar_notif"))
        self.check_ativar_notif.setChecked(self.configuracao.get("notificacoes_ativadas"))
        self.spin_intervalo = QSpinBox()
        self.spin_intervalo.setRange(1, 1440)
        self.spin_intervalo.setValue(self.configuracao.get("intervalo_notificacao"))
        formulario_notificacao.addRow(self.check_ativar_notif)
        formulario_notificacao.addRow(tr("lbl_intervalo"), self.spin_intervalo)
        grupo_notificacao.setLayout(formulario_notificacao)
        layout_principal.addWidget(grupo_notificacao)

        # --- Bot√µes ---
        botoes = QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        caixa_botoes = QDialogButtonBox(botoes)
        caixa_botoes.accepted.connect(self.ao_clicar_ok)
        caixa_botoes.rejected.connect(self.reject)
        layout_principal.addWidget(caixa_botoes)

        self.setLayout(layout_principal)

    def ao_alternar_inicio_sistema(self, marcado):
        self.check_iniciar_min.setEnabled(marcado)
        if not marcado:
            self.check_iniciar_min.setChecked(False)

    def ao_clicar_ok(self):
        # Atualiza configura√ß√µes na mem√≥ria
        self.configuracao["acao_ao_fechar"] = self.combo_fechar.currentData()
        self.configuracao["sincronizar_na_bandeja"] = self.check_sincronizar.isChecked()
        self.configuracao["iniciar_minimizado"] = self.check_iniciar_min.isChecked()
        self.configuracao["notificacoes_ativadas"] = self.check_ativar_notif.isChecked()
        self.configuracao["intervalo_notificacao"] = self.spin_intervalo.value()

        # Grava configura√ß√µes no disco
        mw.addonManager.writeConfig(__name__, self.configuracao)
        
        # Chama a fun√ß√£o de inicializa√ß√£o sem logs
        StartupManager.definir_inicio(self.check_iniciar_sistema.isChecked())

        # Reinicia notificador
        notificador.iniciar_temporizador()
        self.accept()

def mostrar_configuracoes():
    dialogo = DialogoConfiguracoes()
    dialogo.exec()
==================================================

FILE: LICENSE
--------------------
MIT License

Copyright (c) 2025 Caio Graco Purita

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
==================================================

FILE: manifest.json
--------------------
{
    "name": "Anki Tray Pro: Minimizar, Sincronizar & Notificar",
    "package": "AnkiTrayPro",
    "conflicts": [],
    "mod": 1678900000
}
==================================================

FILE: meta.json
--------------------
{"config": {"acao_ao_fechar": "tray", "acao_ao_minimizar": "tray", "sincronizar_na_bandeja": true, "iniciar_minimizado": false, "iniciar_com_sistema": false, "notificacoes_ativadas": true, "intervalo_notificacao": 30}}
==================================================

FILE: notifications.py
--------------------
# -------------------------------------------------------------------------
# Copyright ¬© 2025 Caio Graco Purita. Todos os direitos reservados.
# ARQUIVO: notifications.py
# -------------------------------------------------------------------------
from aqt import mw
from aqt.qt import *
from .lang import tr

class GerenciadorNotificacao:
    """
    Controla um temporizador para verificar periodicamente cart√µes vencidos
    e emitir alertas quando o Anki estiver minimizado.
    """
    def __init__(self):
        self.temporizador = QTimer(mw)
        self.temporizador.timeout.connect(self.verificar_cartoes_vencidos)
        self.iniciar_temporizador()

    def iniciar_temporizador(self):
        """L√™ as configura√ß√µes e inicia ou para o ciclo de verifica√ß√£o."""
        configuracao = mw.addonManager.getConfig(__name__)
        
        if configuracao.get("notificacoes_ativadas"):
            # Converte o intervalo de minutos para milissegundos
            intervalo_ms = configuracao.get("intervalo_notificacao", 30) * 60 * 1000
            self.temporizador.start(intervalo_ms)
        else:
            self.temporizador.stop()

    def verificar_cartoes_vencidos(self):
        """Consulta a cole√ß√£o do Anki para contar revis√µes pendentes."""
        
        # N√£o notifica se a janela estiver vis√≠vel para o usu√°rio
        if mw.isVisible():
            return

        try:
            # Obt√©m a contagem: (novos, aprendizado, revis√£o)
            contagens = mw.col.sched.counts()
            # Considera apenas aprendizado e revis√£o para o alerta
            total_pendente = contagens[1] + contagens[2]
        except:
            # Tratamento de erro caso a API do agendador n√£o esteja dispon√≠vel
            total_pendente = 0

        if total_pendente > 0:
            self.mostrar_notificacao(total_pendente)

    def mostrar_notificacao(self, quantidade):
        """Emite sinal sonoro e exibe bal√£o na bandeja."""
        
        # Emite som padr√£o do sistema
        QApplication.beep()
        
        # Importa o gerenciador de bandeja localmente para acessar o √≠cone
        from .tray import gerenciador_bandeja
        if gerenciador_bandeja.icone_bandeja:
            mensagem = tr("msg_vencidos").format(quantidade)
            
            # Exibe a mensagem flutuante com √≠cone de informa√ß√£o
            gerenciador_bandeja.icone_bandeja.showMessage(
                "Anki", 
                mensagem, 
                QSystemTrayIcon.MessageIcon.Information, 
                5000
            )

# Inst√¢ncia global
notificador = GerenciadorNotificacao()
==================================================

FILE: README.md
--------------------
# Anki Tray Pro üì•

> **Minimize o Anki para a bandeja, receba notifica√ß√µes de estudos e mantenha seu fluxo focado.**

O **Anki Tray Pro** √© um add-on projetado para quem estuda durante o dia todo e precisa que o Anki fique "invis√≠vel", mas acess√≠vel. Ele permite minimizar o aplicativo para a bandeja do sistema (perto do rel√≥gio), sincronizar automaticamente ao esconder e notificar quando houver revis√µes pendentes.

---

## üì• Instala√ß√£o

### Via AnkiWeb
1. Abra o Anki e v√° em **Ferramentas** -> **Complementos** (Add-ons).
2. Clique em **Obter Complementos**.
3. Cole o c√≥digo abaixo:

```text
(C√ìDIGO_DO_ANKIWEB_AQUI)
```

### Instala√ß√£o Manual (Desenvolvedor)
1. Baixe este reposit√≥rio ou clone via Git.
2. Copie a pasta `AnkiTrayPro` para dentro da pasta `addons21` do seu Anki.
3. Reinicie o Anki.

---

## ‚ú® Recursos Principais

| Funcionalidade | Descri√ß√£o |
| :--- | :--- |
| **Minimizar para a Bandeja** | Ao clicar no **X** ou minimizar, o Anki vai para o √≠cone perto do rel√≥gio (Tray) em vez de fechar. |
| **Sincroniza√ß√£o Autom√°tica** | Configure para sincronizar seus decks toda vez que o Anki for enviado para a bandeja. |
| **Notifica√ß√µes de Estudo** | Receba um alerta visual e sonoro discreto a cada X minutos se houver cart√µes vencidos. |
| **Inicializa√ß√£o Silenciosa** | Op√ß√£o para iniciar o Anki j√° minimizado (√∫til para iniciar junto com o sistema). |
| **Totalmente em Portugu√™s** | Interface e configura√ß√µes nativas em PT-BR. |

---

## ‚öôÔ∏è Configura√ß√£o

Acesse o menu **Ferramentas** -> **Op√ß√µes do Anki Tray Pro** para personalizar:

### 1. Comportamento da Janela
* **Ao clicar no 'X' (Fechar):** Escolha entre enviar para a bandeja (padr√£o) ou fechar o programa realmente.
* **Ao minimizar (_):** Escolha se o bot√£o de minimizar padr√£o do Windows deve enviar para a bandeja ou manter na barra de tarefas.

### 2. Sincroniza√ß√£o
* **Sincronizar ao enviar para o Tray:** Garante que seus dados estejam salvos na nuvem sempre que voc√™ "esconder" o Anki.

### 3. Notifica√ß√µes
* Defina se quer ser avisado sobre revis√µes e escolha o **intervalo de verifica√ß√£o** (em minutos).
* *Nota:* As notifica√ß√µes s√≥ aparecem se o Anki estiver minimizado na bandeja, para n√£o incomodar enquanto voc√™ j√° estuda.

---

## üõ†Ô∏è Tecnologias

* **Python 3.9+**
* **Qt6 / PyQt6** (Interface Gr√°fica do Anki)

---

## ¬© Direitos Autorais e Licen√ßa

**Copyright ¬© 2025 Caio Graco Purita.**
Todos os direitos reservados.

Este projeto foi desenvolvido para facilitar a rotina de estudos cont√≠nuos.
==================================================

FILE: tray.py
--------------------
# -------------------------------------------------------------------------
# Copyright ¬© 2025 Caio Graco Purita.
# Todos os direitos reservados.
# ARQUIVO: tray.py
# -------------------------------------------------------------------------
from aqt import mw
from aqt.qt import *
from .consts import *

class GerenciadorBandeja:
    """
    Gerencia a intera√ß√£o com a bandeja do sistema (System Tray) e intercepta
    eventos de janela para alterar o comportamento de fechar.
    """
    def __init__(self):
        # Inicializa a vari√°vel que guardar√° a refer√™ncia ao √≠cone
        self.icone_bandeja = None
        
        # Vari√°vel de controle para saber se devemos fechar de verdade ou minimizar
        self.fechamento_real = False
        
        # Instala os ganchos (hooks) nos eventos da janela principal do Anki
        self.configurar_ganchos()
        
        # Configura o aspecto visual do √≠cone e seus menus
        self.configurar_icone_bandeja()

    def obter_config(self, chave):
        """
        Acessa o gerenciador de addons do Anki para ler uma configura√ß√£o salva.
        """
        return mw.addonManager.getConfig(__name__).get(chave)

    def configurar_icone_bandeja(self):
        """
        Cria o objeto QSystemTrayIcon e define o menu de contexto.
        """
        
        if self.icone_bandeja:
            return

        # Cria a inst√¢ncia do √≠cone de bandeja
        self.icone_bandeja = QSystemTrayIcon(mw)
        self.icone_bandeja.setIcon(mw.windowIcon())
        self.icone_bandeja.setToolTip(DICA_BANDEJA)
        
        # Cria o menu de contexto
        menu = QMenu()
        
        acao_mostrar = QAction("Abrir Anki", menu)
        acao_mostrar.triggered.connect(self.mostrar_janela)
        menu.addAction(acao_mostrar)
        
        acao_sinc = QAction("Sincronizar", menu)
        acao_sinc.triggered.connect(lambda: mw.onSync())
        menu.addAction(acao_sinc)

        menu.addSeparator()

        acao_sair = QAction("Sair Totalmente", menu)
        acao_sair.triggered.connect(self.forcar_saida)
        menu.addAction(acao_sair)

        self.icone_bandeja.setContextMenu(menu)
        self.icone_bandeja.activated.connect(self.ao_clicar_icone)

    def ao_clicar_icone(self, razao):
        if razao == QSystemTrayIcon.ActivationReason.Trigger:
            self.mostrar_janela()

    def mostrar_janela(self):
        """
        Traz a janela do Anki de volta para a tela e ativa o foco.
        """
        mw.show()
        estado_atual = mw.windowState()
        mw.setWindowState(estado_atual & ~Qt.WindowState.WindowMinimized | Qt.WindowState.WindowActive)
        mw.activateWindow()
        mw.raise_()
        
        if self.icone_bandeja:
            self.icone_bandeja.hide()

    def esconder_para_bandeja(self):
        """
        Esconde o Anki e executa sincronia (se configurado).
        """
        
        if self.obter_config("sincronizar_na_bandeja"):
            mw.onSync()

        if self.icone_bandeja:
            self.icone_bandeja.show()
        
        mw.hide()

    def forcar_saida(self):
        """
        Executado ao clicar em 'Sair Totalmente' no menu da bandeja.
        For√ßa sincroniza√ß√£o e encerra o aplicativo.
        """
        # Solicita a sincroniza√ß√£o explicitamente antes de sair
        mw.onSync()
        
        # Define a flag indicando que agora o fechamento √© permitido e definitivo
        self.fechamento_real = True
        
        # Chama o fechamento da janela principal.
        # Isso acionar√° 'ao_evento_fechar', que verificar√° a flag 'fechamento_real'.
        mw.close()

    # --- Tratamento de Eventos (Hooks) ---

    def configurar_ganchos(self):
        self.evento_fechar_original = mw.closeEvent
        mw.closeEvent = self.ao_evento_fechar

    def ao_evento_fechar(self, evento):
        """
        Intercepta o evento de fechamento da janela.
        """
        # Se a flag de fechamento real estiver ativa (clicou em Sair no menu), deixa fechar
        if self.fechamento_real:
            # Chama o evento original para que o Anki fa√ßa sua limpeza padr√£o
            self.evento_fechar_original(evento)
            return

        # Caso contr√°rio, verifica a configura√ß√£o
        acao = self.obter_config("acao_ao_fechar")
        
        if acao == ACAO_BANDEJA:
            evento.ignore()
            self.esconder_para_bandeja()
        else:
            self.evento_fechar_original(evento)

# Instancia o gerenciador globalmente
gerenciador_bandeja = GerenciadorBandeja()
==================================================

FILE: __init__.py
--------------------
# -------------------------------------------------------------------------
# Copyright ¬© 2025 Caio Graco Purita. Todos os direitos reservados.
# ARQUIVO: __init__.py
# -------------------------------------------------------------------------
from aqt import mw
from aqt.qt import *
from aqt import gui_hooks # Ganchos do Anki (hooks)

# Importa nossos m√≥dulos (note que as vari√°veis agora est√£o em portugu√™s)
from .tray import gerenciador_bandeja
from .gui import mostrar_configuracoes
from .lang import tr
from .notifications import notificador

def ao_carregar_perfil():
    """
    Executado assim que o perfil do usu√°rio √© carregado.
    Verifica se o usu√°rio configurou para iniciar o Anki escondido.
    """
    configuracao = mw.addonManager.getConfig(__name__)
    
    if configuracao.get("iniciar_minimizado"):
        gerenciador_bandeja.esconder_para_bandeja()

def configurar_menu():
    """Adiciona a op√ß√£o de configura√ß√£o no menu 'Ferramentas' do Anki."""
    
    # Cria a a√ß√£o no menu com o texto traduzido
    acao = QAction(tr("nome_menu"), mw)

        # Conecta o clique √† fun√ß√£o que abre a janela
    acao.triggered.connect(mostrar_configuracoes)

        # Adiciona a a√ß√£o ao menu Tools (Ferramentas) da janela principal
    mw.form.menuTools.addAction(acao)
    
# --- Registro dos Ganchos (Start) ---

# Adiciona nossa fun√ß√£o √† lista de coisas a fazer quando o perfil abrir
gui_hooks.profile_did_open.append(ao_carregar_perfil)

# Configura o menu imediatamente
configurar_menu()
==================================================

FILE: lang\en.py
--------------------
# English Translations

traducoes = {
    "nome_menu": "Anki Tray Pro Options",
    "grupo_comportamento": "Window Behavior",
    "lbl_fechar": "On 'X' (Close) click:",
    "lbl_minimizar": "On minimize (-):",
    "opcao_bandeja": "Minimize to Tray",
    "opcao_sair": "Quit Anki",
    "opcao_padrao": "Standard (Taskbar)",
    "grupo_sinc": "Synchronization",
    "chk_sincronizar": "Sync before minimizing to tray",
    "grupo_inicio": "Startup",
    "chk_iniciar_sistema": "Start Anki with Windows",
    "chk_inicio_min": "Start Anki minimized to tray",
    "grupo_notificacao": "Notifications",
    "chk_ativar_notif": "Enable due card notifications",
    "lbl_intervalo": "Check every (minutes):",
    "msg_vencidos": "You have {} cards due!",
    "dica_bandeja": "Anki is running in background"
}
==================================================

FILE: lang\pt.py
--------------------
# Tradu√ß√µes em Portugu√™s
# A vari√°vel deve se chamar 'traducoes' para o __init__.py encontrar.
traducoes = {
    "nome_menu": "Op√ß√µes do Anki Tray Pro",
    "grupo_comportamento": "Comportamento da Janela",
    "lbl_fechar": "Ao clicar no 'X' (Fechar):",
    "lbl_minimizar": "Ao minimizar (-):",
    "opcao_bandeja": "Ir para a Bandeja (Tray)",
    "opcao_sair": "Sair do Anki",
    "opcao_padrao": "Padr√£o (Barra de Tarefas)",
    "grupo_sinc": "Sincroniza√ß√£o",
    "chk_sincronizar": "Sincronizar ao enviar para o Tray",
    "grupo_inicio": "Inicializa√ß√£o",
    "chk_iniciar_sistema": "Iniciar Anki junto com o Windows",
    "chk_inicio_min": "Iniciar o Anki minimizado na bandeja",
    "grupo_notificacao": "Notifica√ß√µes",
    "chk_ativar_notif": "Ativar notifica√ß√µes de revis√£o",
    "lbl_intervalo": "Verificar a cada (minutos):",
    "msg_vencidos": "Voc√™ tem {} cart√µes para revisar!",
    "dica_bandeja": "Anki est√° rodando em segundo plano"
}
==================================================

FILE: lang\__init__.py
--------------------
# -------------------------------------------------------------------------
# Copyright ¬© 2025 Caio Graco Purita.
# Todos os direitos reservados.
# ARQUIVO: lang/__init__.py
# -------------------------------------------------------------------------
import importlib
from aqt import mw  # Importa a janela principal do Anki para acessar configura√ß√µes

# Vari√°vel global para armazenar as tradu√ß√µes carregadas na mem√≥ria.
# Funciona como um "cache" para n√£o ler arquivos toda vez.
_traducoes_atuais = {}

def carregar_traducoes():
    """
    Descobre o idioma ATUAL da interface do Anki e carrega o arquivo de tradu√ß√£o correspondente.
    """
    global _traducoes_atuais
    
    # Se o dicion√°rio j√° estiver preenchido, retorna
    if _traducoes_atuais:
        return

    # 1. Obt√©m o idioma atual da interface (Ex: 'en', 'pt', 'ja', 'pt_BR')
    # Usamos 'mw.lang' que reflete a interface, n√£o o padr√£o do perfil
    codigo_idioma = getattr(mw, "lang", "en")
    
    # 2. Pega apenas as duas primeiras letras para simplificar (ex: 'pt' de 'pt_BR')
    idioma_curto = codigo_idioma[:2]

    # 3. Tenta importar o m√≥dulo de tradu√ß√£o dinamicamente
    try:
        # Tenta carregar: .pt, .en, etc. dentro deste pacote
        modulo = importlib.import_module(f".{idioma_curto}", package=__name__)
        
        # Se der certo, pega o dicion√°rio 'traducoes'
        _traducoes_atuais = modulo.traducoes
        
    except ImportError:
        # Se der erro (arquivo n√£o existe), usamos Ingl√™s como fallback
        try:
            modulo = importlib.import_module(".en", package=__name__)
            _traducoes_atuais = modulo.traducoes
        except ImportError:
            # Caso extremo: nem o en.py existe
            _traducoes_atuais = {}

def tr(chave):
    """
    Fun√ß√£o principal de tradu√ß√£o.
    Recebe uma 'chave' (string) e retorna o texto traduzido.
    """
    # Garante que as tradu√ß√µes foram carregadas
    if not _traducoes_atuais:
        carregar_traducoes()
    
    # Retorna a tradu√ß√£o ou a pr√≥pria chave se falhar
    return _traducoes_atuais.get(chave, f"[{chave}]")
==================================================

FILE: templates\ide\vscode\settings.json
--------------------
{
    "files.autoSave": "afterDelay",
    "editor.formatOnSave": true,
    "editor.rulers": [88, 120],
    "editor.tabSize": 4,
    "editor.insertSpaces": true,

    "[python]": {
        "editor.defaultFormatter": "ms-python.black-formatter",
        "editor.formatOnSave": true,
        "editor.codeActionsOnSave": {
            "source.organizeImports": "explicit"
        }
    },

    "files.exclude": {
        "**/.git": true,
        "**/.svn": true,
        "**/.hg": true,
        "**/CVS": true,
        "**/.DS_Store": true,
        "**/Thumbs.db": true,
        "**/__pycache__": true,
        "**/*.pyc": true,
        "**/*.pyo": true,
        "**/*.pyd": true,
        ".venv": true,
        ".pytest_cache": true,
        ".mypy_cache": true
    },

    "python.analysis.typeCheckingMode": "basic",
    "python.analysis.autoImportCompletions": true
}
==================================================

FILE: templates\legal\CABE√áALHO_PROPRIETARIO.txt
--------------------
# -------------------------------------------------------------------------
# Copyright ¬© 2025 Caio Graco Purita. Todos os direitos reservados.
#
# Este arquivo √© parte integrante de um software propriet√°rio.
# A c√≥pia, distribui√ß√£o, modifica√ß√£o ou engenharia reversa n√£o autorizadas
# s√£o estritamente proibidas.
#
# Para permiss√µes de uso ou colabora√ß√£o, contacte o autor.
# -------------------------------------------------------------------------

==================================================

